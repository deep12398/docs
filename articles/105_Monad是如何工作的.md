来源：https://x.com/monad_xyz/status/1848777201006579731

首先，我们将讨论什么是Monad，从开发者的角度和用户的角度分别是什么。

什么是 Monad？ 你可能在网上听说过它作为并行 EVM。它比这要复杂得多，我们今天会深入讲解。实际上，Monad 是一个从头开始重新设计的系统。它看起来非常像以太坊的形态。这意味着它是一个完整的EVM Layer 1等效区块链。如果你曾经在EVM上做过开发，你会觉得它非常相似。但你将能够接触到一个高性能系统，支持每秒10,000笔交易。当我们说10,000笔交易时，我们并不是指转账，而是指真实的以太坊历史交易。我们实际上是通过区块链运行以太坊状态，所以当我们说10,000时，指的是10,000笔真实交易。我们还能够为开发者提供每秒一个块的区块时间和单次插槽的最终性，并且我们保持完全的EVM RPC兼容性。所以你所熟悉的钱包、索引器等工具，基本上可以直接与EVM兼容工作。

从用户的角度来看，Monad是一个地方，让以太坊应用能够找到一个家，真正实现世界计算机的愿景。它是一个高性能、低成本的系统，例如，在Uniswap V2上进行交易，费用仅为几分钱。我们也致力于保持去中心化，这意味着全球有数百个节点参与共识，同时保持合理的硬件要求。接下来我们将详细讲解它是如何做到这一点的。

从开发者的角度来看，Monad是一个完全的EVM等效Layer 1。你可以直接将任何合约移植过来，利用现有的EVM生态系统和网络效应。如前所述，它具有高性能和完整的RPC兼容性。现在，我们将讨论Monad如何解决现有分布式系统的瓶颈，具体的技术是如何解决这些问题的。

在区块链中，实际上有四个基本的约束条件。它们分别是：网络带宽，基本上就是你的互联网带宽；CPU吞吐量，也就是计算机核心的运算速度；状态访问，指的是区块链的数据库和历史状态；以及状态增长，指的是当前账户及其余额等信息，以及能够拉取这些信息的能力。

那么以前存在的一些方法是，许多区块链通过某些手段来实现特定的属性。最简单的一种捷径就是让你拥有非常好的互联网连接。因此，我们的目标是消费者完整节点的互联网带宽达到100兆比特每秒。许多区块链运行在1千兆比特或10千兆比特的连接上。显然，如果你提高带宽要求，你可以通过这种方式来扩展。显然，拥有更好的互联网连接会花费更多的钱。

另一种实现这些属性的方法是将所有节点放得更近一些。你不能作弊物理定律。光速需要时间才能在全球范围内传播。那么如何作弊物理定律呢？你只需要把所有节点放在同一个地方，这样光速传播的距离就更短，时间也会更短。

还有一些区块链选择通过提高RAM要求来实现这些属性。显然，这会让节点变得非常昂贵。RAM是任何计算机系统中最昂贵的部分，因此，如果要求人们将整个区块链的状态存储在RAM中，尤其是当你需要非常昂贵的计算机时，成本就会非常高。

所以，真正的目标是什么呢？我们的目标是最大限度地利用商品硬件，我们需要设计能够充分利用硬件的程序，克服这些后续瓶颈，同时保持去中心化。这意味着要有合理的RAM要求，且全球范围内完全分布，拥有数百个节点。

那么我们是如何做到这一点的呢？实际上，这是通过一种新的软件架构来实现的，它考虑了所有这些问题，并找到了最佳的方法来使每个带宽饱和，从而解决这些不同的瓶颈。事实上，这是对架构的全新设计。唯一保留下来的就是EVM字节码，也就是说，EVM如何解释代码的指令。

但我们重建了共识机制、重建了执行引擎，实施了并行执行，并且我们还有一个完全自定义的状态数据库，叫做MonadDB。今天我们将讨论其中的后三个部分。共识机制需要更多时间，我认为今天没有足够时间讨论。如果你有任何问题，可以在之后来问我，我很乐意回答或者给你一些文档，供你进一步阅读。

今天我们首先要讨论的是异步执行。为了做到这一点，我们需要看看当前大多数区块链是如何工作的。这是通过一种叫做交错执行的方法实现的。

交错执行实际上是异步执行的对立面。那么什么是交错执行呢？它基本上意味着执行和共识是在区块时间内同时进行的。以以太坊为例，它的区块时间是12秒。这相当于每个区块在提出新块之前需要达成共识的时间。

在以太坊中，我们看到执行占据了区块时间的一部分，而共识则花费更多的时间。为什么共识要花费更多时间呢？因为是全球各地的节点在进行通信，显然，光速传播需要时间，所以这需要较长时间。

在典型的区块链中，我们看到的就是交错执行。执行部分在深蓝色区域，共识部分在浅蓝色区域，框架内是区块时间。显然，随着区块的产生，它们会形成一个链条，随着时间推移，我们会看到类似这样的效果。

如果是异步执行，它实际上源于这样的认识：你可以将执行从共识之外分离出来。或者，基本上来说，它源自于这样一个事实：如果你有一个确定性的状态机，如EVM，你知道交易的顺序，知道每笔交易中的数据，那么实际上你并不需要执行才能知道结果总是相同的。因为如果你知道X和Y，而且你知道加法的规则，那么X+Y总是等于X+Y，你知道如何进行加法操作，结果总是一样的。因此，只要你指定了X和Y，你就能知道输出结果。


因此，意识到这一点后，我们知道我们实际上可以将执行从当前区块中分离出来，并与下一个区块一起进行。因此，你可以在执行前一个区块的同时进行当前区块的排序，也就是说，你在排序当前区块的同时执行前一个区块。这使得我们可以像这样实现（如图所示）。你要注意的一点是，现在共识和执行处于不同的两侧，对吧？我们实际上是在达成共识，确定数据是什么，以及数据的衍生数据是什么，然后在我们知道这些之后再执行它，同时进行下一个区块的排序。

如果我们把它们并排放置，效果大概是这样的。我们可以放一些区块时间的内容，你可以看到它们有些部分是重叠的。这使得我们可以做一些“魔法”。现在，由于我们在并行做两件事，执行可以占用整个区块时间。我们不再受限于区块时间的限制。


因此，我们在达成共识并确定当前区块的排序和数据的同时执行前一个区块。这使得我们能够大幅扩展执行预算，从而扩展燃气预算，这直接导致更高的吞吐量、更低的费用以及我们最初提到的所有优点。

是的，我刚才已经提前解释了很多内容，但简单回顾一下，基本上，节点在执行之前就达成共识，确定交易的排序。我们正在并行处理两个区块。为了确保所有节点保持同步，并且不会出现延迟的状态视图，我们在执行时需要进行一些检查。简单来说，在达成共识后，节点必须本地执行以获取该状态。然后，这些状态会在后续的共识中再次验证，以确保所有节点都同意相同的状态变化。

这使得我们能够大幅扩展燃气预算，很多区块链也在朝这个方向发展。例如，Solana现在就有类似的提案。这是一个工程问题，一旦你意识到这是可能的，就会发现这样做没有太多缺点，并且能提供更大的燃气预算。

需要注意的一点是，最终性发生在共识时。尽管我们稍后才执行区块，但正如我所说，如果你知道数据的顺序，并且知道每个区块中的数据，那么在那一刻它就已经是最终的了。因为你知道EVM是如何工作的。所以如果你有一个全节点，你可以在达成共识后本地运行这些交易，并在共识完成后立即获取状态更新。

好的，我们刚刚讨论了同步执行，接下来我们要讨论的是并行执行。这可能是你几个月前听说的Monad，那个时候它成为了Twitter上的热门话题，大家都在讨论并行执行。那么，我们来看看Monad是如何实现的。并行执行的一个简单理解就是将一条道路分成多条道路。如今的计算机通常有多个核心，实在没有理由不加以利用。

我们来充分利用这些硬件资源吧。那么，今天的事务大多数是线性有序并且串行执行的。这是我们通常在脑海中想到的逻辑——事务进入区块后，它们有一个排序，然后按顺序执行。

然而，我们真正想做的是保持共识给我们的排序，同时让所有事务并行执行，这样可以更快地得到结果，然后按照最初的顺序提交它们。那么我们是如何做到的呢？我们使用了一种叫做“乐观并行执行”的方法，它也有几个不同的名字，比如软件事务内存（STM），乐观并发控制（OCC）。但本质上，它是一个非常直观的想法。

基本上，你从一个同步的世界视图开始。

你假设所有事务都可以并行执行，然后生成一堆待处理的结果。接着，你按照顺序遍历这些待处理的结果，尝试提交它们。如果你发现有任何待处理的结果依赖于之前的某个结果，那么你就重新执行这些事务。我们通过一个简单的例子来解释这个过程：

假设我有1000 USDC，Alice什么都没有，Bob有300 USDC。我想分别给Alice和Bob各转账100 USDC。显然，最终的结果应该是我有800 USDC，Alice有100 USDC，Bob有400 USDC。在这个过程中，可能会有一些与转账无关的事务，你将看到它们如何影响执行。

基本上，开始时我们假设所有事务都可以并行执行，因此我们生成一些待处理的结果。然后，我们开始逐步处理这些结果，假设我从1000 USDC开始，执行完第一笔转账后，我有900 USDC，我们提交这个结果，不会看到冲突，假设初始状态是我们假设的那样。接着进行第二笔转账，它不会影响之前的状态，继续处理第三笔转账。第三笔转账提交后，我已经有900 USDC，而这笔转账假设我是从1000 USDC开始的，显然存在冲突。那么，如何解决这个冲突呢？我们只需要使用新的状态重新执行这笔事务。

需要注意的是，我们基本上是基于相同的起始点执行一堆事务，生成待处理结果，提交它们，并在必要时重新执行。算法的工作原理是，由于我们是按顺序提交这些事务的，因此你不需要实际多次执行同一个事务。如果我们考虑计算机中最耗时的部分，实际上是从数据库中调用事务的状态。

执行是非常便宜的。实际上，真正耗费大量时间的部分是访问硬盘，将数据从硬盘读取到内存中。而从那之后，执行的过程是非常轻量的。因此，这使得我们能够在重新执行时，开销并不会很大，因为我们已经提前将所有状态缓存起来，即使需要重新执行，它也是一个相对轻便的操作。

这个模型的一个很酷的地方是，你不需要处理访问列表。访问列表对于开发者来说有点复杂，且它们会占用带宽。我们必须向区块链发送更多的信息，这显然会增加带宽上的开销。因此，本质上，你可以保持和以太坊虚拟机（EVM）相同的接口体验，同时在后端保持并行系统的性能。

但使得这一切成为可能的，实际上是 **MonadDB**。接下来，我们将深入探讨 **MonadDB** 的魔法。请耐心听我讲解，这部分可能是最复杂的内容。

**MonadDB** 本质上使得以太坊状态在逻辑上变得原生，适应以太坊的工作方式。那么，这是什么意思呢？它是支持并行执行并保持饱和的东西，通过允许并行的状态访问。正如我之前提到的，你需要从数据库中拉取依赖项，如果计算机每次都在等待数据库的访问，那就算你有并行执行，也没有意义，因为每个事务在执行时都得等待数据库返回数据。因此，真正需要的，是同步的输入输出（I/O），这样你就可以并行地发出多个请求到数据库，然后当这些请求返回时，立即执行。

现在，让我们看看现代硬盘的一些背景信息。现代硬盘实际上是非常酷的技术产品。你花大约200美元，就能买到一块带有高带宽的固态硬盘（SSD），它每秒能够进行百万次I/O操作。虽然硬盘的查找时间大约是40到100毫秒，而内存（RAM）的查找时间是0.1毫秒，但硬盘一次可以处理更多的操作。因此，重要的是要饱和这种内存带宽，并始终并行地从状态中拉取数据，以确保系统的其他部分不会因为等待而成为瓶颈。

接下来我们要讨论的，是以太坊如何存储状态，这也是这部分最复杂的内容之一。以太坊使用一种叫做 **Merkle Patricia Trie**（很多人简称为Merkle Patricia树）的结构来存储状态。Merkle Patricia Trie 是一种树形结构，技术上称为 “Trie” （前缀树）。很多其他数据库，如 Go Ethereum、LevelDB 和 Aragon 等客户端，也使用类似的 off-the-shelf（现成）数据库来存储这棵树。

这些数据库本身并不是 Merkle Patricia Trie（MPT）。它们通常使用像 B 树或 LSM 树这样的其他树形结构，这些是大多数常见数据库所使用的树形结构，因为在计算机科学的其他领域中，这些结构是高效的查找存储方式。

那么，为什么我们要使用 Merkle Patricia Trie 呢？这几乎可以说是以太坊存在的哲学基础。它使得事务和状态的简洁验证成为可能。这意味着你能够检查某个数据根，并确定该根下的所有数据是否符合预期。因此，在很多没有 Merkle Patricia Trie 的区块链中，为了检查某个事务是否包含在内，你实际上必须下载整个区块，一一重新执行，然后判断该事务是否存在。而以太坊则认为，能够仅仅通过查看一个区块来验证事务是否确实发生是非常重要的，而它使用的这种数据结构正是 Merkle Patricia Trie。

你可以把它想象成底部有很多数据叶子，接着是逐对的哈希值，逐步向上构成这棵树。这样，如果树中的任何一个数据元素发生变化，所有向上的哈希值都会随之改变。因此，如果你有这个根哈希，你基本上就能知道底层的所有数据都是你所提交的。如果任何数据发生了篡改或变化，都会生成不同的哈希值。

当然，理论上你可以在没有 Merkle Patricia Trie 的情况下做到这一点，但就像我之前提到的，那时的开销就变得非常大：你需要下载整个区块，获取历史状态，然后一一执行，确保一切正常。而以太坊之所以选择使用这种数据结构，就是因为它想提供简洁的区块链事务验证，这也是以太坊的主要价值之一。

因此，尽管以太坊采用了逻辑上是 Merkle 树的数据结构，但它们实际使用的物理树并不是 Merkle 树。这正是为什么其他数据库通常并不采用这种结构，因为大多数数据库并不需要提供以太坊所提供的简洁可验证性。这也是以太坊的核心特性之一。


在以太坊的状态存储中，实际执行状态树遍历时，背后的数据库结构并不像 Merkle 树，而是基于诸如 LevelDB 或 PebbleDB 这类 LSM 树结构。这就导致了“树遍历中的树遍历”问题：在从根哈希向下查找子节点时，你需要进入 LevelDB 或 PebbleDB，进行额外的树遍历查找，这样的开销是传统方法的16到32倍。

MonadDB 通过彻底重构数据库来解决这个问题。它直接在磁盘上将 Merkle Patricia Trie 作为数据存储方式，从而消除了树遍历中的间接层级。当你在 Merkle Trie 中查找数据时，实际上就是数据库本身在存储和查询数据。这意味着，不管存储的是文本、数字，还是以太坊的区块链状态，数据都将直接以 Merkle Patricia Trie 的形式存储。

这种结构的核心优势是显著减少了每次树遍历时的查找次数，降低了16到32倍的开销。结合之前提到的异步 I/O 机制，你可以在执行事务时并行地拉取状态数据，从而最大化利用计算资源，并提高整个系统的执行效率。通过这样的设计，MonadDB 使得以太坊能够实现高效的并行状态访问和并行执行。

因此，MonadDB 不仅是一个自定义的状态数据库，它还通过在磁盘上原生存储 Merkle Patricia Trie 和利用异步 I/O 机制，实现了并行查询和执行的高效性。这正是使得以太坊能够实现并行执行的秘密武器。通过这种方式，MonadDB 解决了传统数据库结构中存在的瓶颈，让并行执行变得可行并高效。

总结来说，MonadDB 为以太坊提供了一种高效的状态管理方式，通过将 Merkle Patricia Trie 原生集成到存储结构中，以及使用异步 I/O 技术进行并行查询，极大地提高了并行执行的性能。这是实现高效并行执行的关键所在。

TODO: 结束语
